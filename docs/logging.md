# Logging

The interpreter provides a logging facility to trace the RPG program execution.
To enable the log functionality it is required to specify the configuration file using the **-lc** or  **--log-configuration** on the runner command line, the muterunner command line or for any other tool.

The logging permits to monitor the interpreter behaviour at the runtime. The logging messages are is subdivided in channels, each one designed to capture a specific aspect of the interpreter. 

The output consists of a set of data records, with a fixed header segment with common data and a variable data segment specific for each channel. 

The values of the record are separated by a character specified in the configuration  file. This permits to easily process the resulting logs as CSV files or using comman line tools such as cut.

The available channels are:

* **Data:** monitors the accesses to the variables.
* **Expression:** traces the expressions encountered during the program execution.
* **Statement:**  provides information about the statements executed.
* **Loop:** captures the loop execution including the number of iterations.
* **Performance:** measures the execution time.
* **Parsing:** measures parsing phase time.
* **Resolution:** provides information about the process to identify the routines or programs to invoke. 
* **Error:** provides information about error event occurred during the whole cycle of program interpretation.

## Sample

```shell script
java -jar /home/<user>/git-projects/jariko/rpgJavaInterpreter-core/build/libs/rpgJavaInterpreter-core-all.jar -lc /home/<user>/jariko_rpg/logging.config /home/<user>/jariko_rpg/X1_X21_03C.rpgle
```
* _the rpgJavaIntepreter-core-all.jar required can be generated by **./gradlew fatJar** command, see [the development guide](development.md#creating-a-jar-with-all-dependencies-to-run-some-examples)_
* _it could be necessary to run above 'java -jar...' command directly from .rpgle container directory, or tell the interpreter the [Program Search Directories](development.md#program-search-directories) via the the -psd start opition_

You can enable logging also in case of you want switch on the "mutes" interpretation.
```shell script
java -jar /home/<user>/git-projects/jariko/rpgJavaInterpreter-core/build/libs/rpgJavaInterpreter-core-mute-all.jar -lc /home/<user>/jariko_rpg/logging.config /home/<user>/jariko_rpg/X1_X21_03C.rpgle
```
* _the rpgJavaInterpreter-core-mute-all.jar required can be generated by **./gradlew fatMuteJar** command, see [the development guide](development.md#creating-a-jar-with-all-dependencies-to-run-some-examples)_

## Configuration File
The logging configuration file is a plain text file containing the parameters to enable/disable the channels and set the output device. 

```
#
#  Logging configuration file
#

logger.data.separator =  \t
logger.date.pattern = HH:mm:ss.SSS

logger.file.path = /var/log/smeup-rpg
logger.file.name = log.log

data.level = all
data.output = console

loop.level = all
loop.output = console

expression.level = all
expression.output = console

statement.level = all
statement.output = file

performance.level = all
performance.output = console

resolution.level = off
resolution.output = console

parsing.level = off
parsing.output = console

error.level = off
error.output = console

```

The value specified in **logger.data.separator** is the character used to 
separate the values within a record. 

Each record has contains a timestamp in the **logger.date.pattern** allows
to specify the format of the data. 

The logging allows to redirect the output to the console or to file. 
In case of file the parameters **logger.file.path** and **logger.file.name** 
allow to set the path and the filename of the log file. 

The channel configuration consist of two values: **level** and **output**. 

* The **level** allows to enable or disable the channel, the possible values are
**all** and **off**.

* The **output** parameter specifies where the log will be redirected, in case is set
to **console**, the logging information are written on the screen otherwise if 
set ot **file** the data will be appended to the file specified by **logger.file.path** 
and **logger.file.name**. 

## Passing the configuration without a file

If you don't want to pass the configuration to the logging system using a file, you could use the ```consoleLoggingConfiguration``` or the ```fileLoggingConfiguration``` fun.
For example:
```
val si = JavaSystemInterface(consoleLoggingConfiguration(EXPRESSION_LOGGER, PERFORMANCE_LOGGER))
```   
or
```
val si = JavaSystemInterface(fileLoggingConfiguration(File("/home/pippo", "example.log"), EXPRESSION_LOGGER, PERFORMANCE_LOGGER))
```   

## Log file format

Each log record consists of a fixed header containing the common data and a 
variable data segment which depends on the channel.


```
<TIMESTAMP><S><PROGRAM><S><LINE><S><CHANNEL><S><CHANNEL SPECIFIC>
+------------------ header -------------------+----- data ------+
```     

The header contains the following data:

* **TIMESTAMP** timestamp of the record
* **PROGRAM** name of the program, if available
* **LINE** the line of code, if available, or lines number of source code
* **CHANNEL** a mnemonic name of the channel 

The **S** represent the separator character specified in the configuration.

## Data Channel DATA
The monitors the accesses to the variables during the program execution.  

```
14:25:29.471 TEST_06          DATA NBR = 0            10
+-----------+-------------+--+---+---- data -----+- result -+
```     
The log record collects the initial value zero in this case and the new value
assigned by a statement. In the example above the value of variable NBR has an
initial value of 0 (zero) and assume the value of 10.


## Statement Channel STMT
The statement channel captures information about the statement executed.  

```
11:30:38.893 TEST_06       45 STMT EVAL WORDINC = J - I	   5
+-----------+-------------+--+---+---- statement -----+- result -+
```     

In the example above the record contains the statement executed `EVAL WORDINC = J - I`
and the result of the expression, in this case **5**.

When statement evaluate a comparison operator the result represent the logical
value of the expression.

```
11:30:38.893 TEST_06       45 STMT	SELECT WHEN	NBR = 0	(false)
11:30:38.893 TEST_06       47 STMT	SELECT WHEN	NBR = 1	(true)
+-----------+-------------+--+---+---- statement -----+- result -+
```

The statement channel also tracks the start and the end of a
program or subroutine. 

```
11:30:38.893 TEST_06       45 STMT	SELECT SUBROUTINE START	FIB

11:30:38.893 TEST_06       55 STMT	SUBROUTINE END	FIB
+-----------+-------------+--+---+--------- statement ---------+ 
```

## Expression Channel EXPR
The expression channel collect all the expressions encountered during the program execution.

```
14:14:30.330 TEST_06       28 EXPR A + B                3
+-----------+-------------+--+---+-- expression --+- result -+
```


## Loop Channel LOOP
The loop channel captures the execution of loops.
Two log records are created, the first when the loop starts and second
when the loop exits. The end loop record include the number of cycles 
actually executed.

```
14:14:30.330 TEST_06       28 LOOP FOR J = 1  TO 4
14:14:30.571 TEST_06       35 LOOP ENDFOR J              4
+-----------+-------------+--+---+----- loop ------+- result -+
```

The example below shows a DOW loop execution.

```
14:14:30.330 TEST_06       13 LOOP DOW LOOP START COUNT < 100 
14:14:30.556 TEST_06       22 STMT LEAVE
14:14:30.571 TEST_06       33 LOOP DOW LOOP END                   45	
+-----------+-------------+--+---+---------- loop -----------+- result -+
```
Please note that statements like LEAVE may affect the number of cycles
actually executed.

## Performance Channel PERF
The performance channel measures the execution time of loops, programs and
subroutines. 
The log records are generated at the end of statements block, measuring the
time in milliseconds.

```
15:09:46.910 TEST_06       79 PERF ENDFOR I                       8 ms
15:09:46.910 TEST_06       80 PERF SUBROUTINE END PRINT           9 ms
15:09:46.910 TEST_06          PERF END TEST_06                  160 ms
+-----------+-------------+--+---+---------- data -----------+- result -+
```

## Parsing Channel PARS
The parsing channel measures the parsing time needed to build AST.
The log records are generated at the end of each phase related to parsing.

```
12:36:33    MUTEXX        182 PARS PREPROP END MUTEXX          165 ms
12:36:33    MUTEXX        182 PARS RPGLOAD END MUTEXX          127 ms
12:36:33    MUTEXX            PARS LEXER END MUTEXX            236 ms
12:36:34    MUTEXX            PARS PARSER END MUTEXX           674 ms
12:36:41    MUTEXX            PARS RCONTEXT END MUTEXX        7191 ms
12:36:41    MUTEXX            PARS CHKPTREE END MUTEXX          17 ms
12:36:42    MUTEXX            PARS AST END MUTEXX              361 ms
+-----------+-------------+--+---+---------- data ------------+- result -+
```


## Resolution Channel RESL
The resolution channel provides information about the action taken in order
to resolve a program. When the interpreter starts, the RESL channel logs the list
of strategies used to locate a RPG/Java program.

```
15:09:46.910                  RESL resource: /
15:09:46.910                  RESL directory: .
15:09:46.960 TEST_06       80 RESL CALL "CALCFIB"
+-----------+-------------+--+---+---------- resolution -----------+
```

## Error Channel ERR
The error channel catches the error events (instances of `com.smeup.rpgparser.execution.ErrorEvent`).
These events are particularly meaningful during the program syntax checking, below we can see an example.
As you can see, the `ErrorEvent` is shown through its string representation.
```
12:24:28.735 	ERROR02	6	ERR	ErrorEvent(error=java.lang.IllegalStateException: token recognition error at: 'C    ', errorEventSource=Parser, absoluteLine=6, sourceReference=SourceReference(sourceReferenceType=Program, sourceId=ERROR02, relativeLine=6, position=Position(start=Line 6, Column 6, end=Line 6, Column 6)), fragment=      C                   EVAL      x = 1 / n)
12:24:28.739 	ERROR02	7	ERR	ErrorEvent(error=java.lang.IllegalStateException: missing FREE_SEMI at 'C', errorEventSource=Parser, absoluteLine=7, sourceReference=SourceReference(sourceReferenceType=Program, sourceId=ERROR02, relativeLine=7, position=Position(start=Line 7, Column 5, end=Line 7, Column 5)), fragment=     C                   SETON                                        LR)
+-----------+-------------+--+---+---------- error ----------------+
```

For further information about the `ErrorEvent` see the kotlin-doc in [Configuration.kt](../rpgJavaInterpreter-core/src/main/kotlin/com/smeup/rpgparser/execution/Configuration.kt)

